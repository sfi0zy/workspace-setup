# if not running interactively, don't do anything

case $- in
    *i*) ;;
    *) return;;
esac

# âœ“ [08:45 AM] username:hostname ~ $
# And we disable the warning about checking exit code of a previous command
# shellcheck disable=2181
set_bash_prompt() {
    local green="\[\033[01;32m\]";
    local red="\[\033[01;31m\]";
    local white="\[\033[01;00m\]";
    local yellow="\[\033[01;33m\]";
    local blue="\[\033[01;34m\]";
    local pink="\[\033[01;35m\]";
    local reset_color="\[\033[00m\]";

    local ok_mark="\342\234\223";
    local not_ok_mark="\342\234\227";
    local last_command_time="[\@]";
    local user_name="\u";
    local host_name="\h";
    local working_directory="\w";

    local commits_count
    local git_info

    PS1=""

    if [[ $? == 0 ]]; then
        PS1+="${green}${ok_mark} "
    else
        PS1+="${red}${not_ok_mark} "
    fi

    PS1+="${last_command_time} "
    PS1+="${red}${user_name}";
    PS1+="${white}:"
    PS1+="${yellow}${host_name} "
    PS1+="${blue}${working_directory}"

    if [[ -d .git ]]; then
        PS1+="${pink} | git"

        commits_count=$(git rev-list --all --count)

        if [[ "${commits_count}" == "0" ]]; then
            PS1+=":NO COMMITS HERE"
        else
            git_info=$(git rev-parse --abbrev-ref HEAD)
            PS1+=":${git_info}"
        fi

        PS1+=" $"
    else
        PS1+=" $"
    fi

    PS1+=" ${reset_color}"
}

PROMPT_COMMAND=set_bash_prompt

# see bash(1) for more options for history

HISTCONTROL=ignoreboth
HISTSIZE=1000
HISTFILESIZE=2000

# append to the history file, don't overwrite it

shopt -s histappend

# save and reload history after each command finishes

export PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# use vim as default text editor

export EDITOR=vim

# check the window size after each command

shopt -s checkwinsize

# various alias

alias ..='cd ..'
alias ...='cd ../../'
alias ....='cd ../../../'

alias ls='ls --color=auto'
alias ll='ls -lAhF'
alias cp='cp -i'
alias mv='mv -i'
alias mkdir='mkdir -pv'
alias grep='grep --color=auto'
alias top='htop'

alias bash-reload='source ~/.bashrc'

alias npm-list-global-packages='npm list -g --depth=0'
alias npm-list-global-updates='npm outdated -g --depth=0'
alias npm-update-globals='npm update -g'

alias apt-update-all='sudo apt update && sudo apt upgrade'
alias apt-remove-unused='sudo apt autoremove'

alias check-internet-connection='ping 8.8.8.8 -c 5'

alias serve-this-directory='http-server -c-1'
alias share-this-directory='http-server -c-1 & ngrok http 8080 && kill $!'

alias random-string='cat /dev/urandom | tr -cd "a-f0-9" | head -c 32'

alias git-graph='git log --graph --full-history --all --color' \
        '--pretty=format:"%x1b[31m%h%x09%x1b[32m%d%x1b[0m%x20%s"'

# add ruby gems and snap packages to PATH

export GEM_HOME="$HOME/gems"
export PATH="$HOME/gems/bin:$PATH"
export PATH="$PATH:/snap/bin"

#######################################
# Archive all documents, except node_modules, encrypt and split it
# Arguments:
#   None
#######################################
backup-documents() {
    set -e

    local documents_folder_size
    local documents_folder_size_h
    local space_needed
    local space_needed_h
    local free_space
    local free_space_h

    documents_folder_size=$(du -bs ~/Documents/ | cut -f1)
    documents_folder_size_h=$(numfmt --to iec "${documents_folder_size}")
    space_needed=$((2 * documents_folder_size))
    space_needed_h=$(numfmt --to iec "${space_needed}")
    free_space=$(df --output=avail -B 1 . | tail -n 1)
    free_space_h=$(numfmt --to iec "${free_space}")

    echo "Documents folder size: ${documents_folder_size_h}"
    echo "Space needed: ${space_needed_h}"
    echo "Free space: ${free_space_h}"

    if (( space_needed > free_space )); then
        echo "You need more free space to perform this."
        return 1
    fi

    echo "Enter password:"
    read -r -s password_for_archive
    echo "Enter the same password second time:"
    read -r -s password_for_archive_copy

    if [[ "${password_for_archive}" != "${password_for_archive_copy}" ]]; then
        echo "Two entered passwords are different. It'll be safer to try again."
        return 1
    fi

    echo "OK"
    current_date=$(date '+%Y-%j')
    archive_filename="backup_${current_date}"
    echo "Archive name will be ${archive_filename}"
    echo "Archiving (this may take some time)..."
    zip -r "${archive_filename}.zip" ~/Documents/ -x -- *node_modules*
    echo "OK"

    echo "Testing archive..."
    unzip -t "${archive_filename}.zip"
    echo "OK"

    echo "Encrypting archive (this may take some time)..."
    gpg --pinentry-mode=loopback --yes \
        --passphrase "${password_for_archive}" \
        --output "${archive_filename}.gpg" \
        --symmetric "${archive_filename}.zip"
    echo "OK"

    echo "Removing unencrypted archive..."
    rm "${archive_filename}.zip"
    echo "OK"

    echo "Splitting archive (this may take some time)..."
    split --bytes=500M "${archive_filename}.gpg"
    mkdir -p "${archive_filename}"
    mv x* "${archive_filename}"
    echo "OK"

    echo "Removing unsplitted archive..."
    rm "${archive_filename}.gpg"
    echo "OK"

    echo "Encrypted and splitted archive is in ${archive_filename} directory"

    echo "The backup has been created. It's time to copy it."
    notify-send "The backup has been created. It's time to copy it."
}

#######################################
# Concat, decrypt and extract backup created with backup-documents()
# Arguments:
#   None
#######################################
extract-backup() {
    set -e

    echo "Enter password:"
    read -r -s password_for_archive
    echo "OK"

    echo "Concatting files (this may take some time)..."
    cat x* > backup.gpg
    echo "OK"

    echo "Removing splitted archive..."
    rm x*
    echo "OK"

    echo "Decrypting archive (this may take some time)..."
    gpg --pinentry-mode=loopback --yes \
        --passphrase "${password_for_archive}" \
        --output backup.zip \
        --decrypt backup.gpg
    echo "OK"

    echo "Removing encrypted archive..."
    rm backup.gpg
    echo "OK"

    echo "Extracing archive (this may take some time)..."
    unzip backup.zip
    echo "OK"

    echo "Removing archive..."
    rm backup.zip
    echo "OK"

    echo "Finished."
}
